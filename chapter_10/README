Chapter 10 - Reactive Processes Using Drools Fusion

The Projects included in chapter 10 cover:
 - drools5-fusionSimpleExample: This project contains a set of tests and a Swing UI using the same rules file to show how to deal with real time events generated by the keyboard.

Let’s start with the Tests examples first. These tests use the PSEUDO Clock to control how time flows. We commonly use the PSEUDO Clock to write deterministic test cases that require time evaluations. Using the Real Time Clock can cause race conditions; if the test runs in a busy environment, which can influence the test performance. 

In this section, we will analyze the Test Class called: MyFirstDrools5FusionRulesTest. Inside this class, we have a couple of tests that use the simpleEventAnalysis.drl rule file to run. The first thing that we need to look at is how we configure our Knowledge Session to use the Drools Fusion capabilities. Inside the MyFirstDrools5FusionRulesTest class, you will find a method called createKnowledgeSession() that sets up our session, which  we will use to analyze incoming events. 
If you take a look at the createKnowledgeSession() method, you will find two differences that separate this from the rest of the examples in this book. The first one is how we configure the Knowledge Base to be in STREAM mode. 
KnowledgeBaseConfiguration config =
     KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption(EventProcessingOption.STREAM);
KnowledgeBase kbase = 
            KnowledgeBaseFactory.newKnowledgeBase(config);
By default, the engine runs in CLOUD mode, which is how a Rule Engine normally behaves. There is no concept of now, so the use of sliding windows is not possible, and all events and facts are treated equally at evaluation time. Setting up the Knowledge Base to use the STREAM mode enables the engine to have the concept of Now, as well as event ordering, sliding windows, and automatic event life cycle management.  
The second difference is that we have to set up the Knowledge Session to use the PSEUDO Clock. By default, the REAL TIME Clock is used, so we need to change it if we are planning to test in a controlled environment.
KnowledgeSessionConfiguration sessionConfig = 
      KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
sessionConfig.setOption( ClockTypeOption.get("pseudo") );
return kbase.newStatefulKnowledgeSession(sessionConfig, null); 
To make sure you remember, we have set up the Clock Type at session level, because our session represents our live world, which needs to have the concept of time. The Event Processing type CLOUD/STREAM is being set at the Knowledge Base level. This is because the evaluation RETE network structure will be constructed differently if we are using the STREAM mode. 
Once we have our session ready, we need to understand a little bit more about the problem that we are trying to solve. In this case, because we will be analyzing Keyboard Events, we have defined three different event types called: KeyA, KeyS, and KeyD. If you open these classes, you will find that they don’t contain anything. They are just being used to represent the different event types that can happen in our application. In order to let the engine know that these classes need to be treated as events, we will need to mark them with the @role annotation inside our DRL file.
If you take a look inside the simpleEventAnalysis.drl file, you will see that we are doing exactly that:
declare KeyA
    @role( event )
end

declare KeyS
    @role( event )
end

declare KeyD
    @role( event )
end

declare KeyW
    @role( event )
end
Notice that we are also defining another event called KeyW that is not defined as a Java Class in our model. This is another cool thing that we can do inside our DRL files: we can define types that are dynamically generated by the Drools Runtime without the need of having a Java Class to represent them. 
Now that we have declared all our event types, we can start writing rules about them. Let’s take a look at the two rules provided inside the DRL file.
rule "more than 3 key A in the last 10s"
    when
        Number($value: doubleValue > 3) from accumulate( $a: KeyA() over window:time(10s), count($a))
    then
        System.out.println(" >>> KeyA Pressed - count: "+$value);
end
This first rule is using the Time Sliding Window to check if we have pressed the A Key more than three times in the last 10 seconds. In other words, if we have pressed the A Key more than 3 times, this rule will be activated. Remember that the engine will have the same behavior as though it were dealing with facts.  This means that if we press the A Key 4 times in a 10 second period, we will get one activation for this rule; if we generate 5 A Key events in a 10 second period, we will get two activations; and so on. 
The test called testSimpleEvents() shows the first rule in action.  Notice that because we are using the PSEUDO Clock, we will have to move the time forward when we need to.
SessionPseudoClock clock = ksession.getSessionClock();
int fired = 0;
// Initial time 0s -> t0
ksession.insert(new KeyA());
fired = ksession.fireAllRules();
clock.advanceTime(2, TimeUnit.SECONDS);
assertEquals(0, fired);
As you will see in the tests, we can get the clock reference and influence how the time flows using the advanceTime() method. Feel free to change the tests to see how you can generate more rules activations and firings. Notice that we are not using the reactive mode here (fireUntilHalt() method), so we need to call the fireAllRules() method after each insertion.  
The second rule inside the DRL file doesn’t use the sliding windows feature.  It just looks for a specific pattern (in this case, a sequence of events). 
rule "key A + key S + key D pattern"
    when
        $a: KeyA()
        $s: KeyS( this after[1ms, 100ms] $a)
        $d: KeyD( this after[1ms, 100ms] $s)
    then
        System.out.println(" >>> KeyA +Key S + KeyD pattern detected");
end
This rule checks for an occurrence of the KeyA event followed by a KeyS event followed by a KeyD event. As you can see, this rule will only be activated when this sequence happens with less than 100ms between these events. If these events happen in a different order or in a different time period, the rule will not be activated. 
The tests called testPatternDetectionEvents() show these rules in action. Notice that both rules are being evaluated at the same time, but because they are both checking for different conditions, we can have them in the same Knowledge Session without any problems. Once again, feel free to change the test and play around with the PSEUDO Clock to see how these rules react. 
	
 - jBPM5-Process-Events-Patterns: This project contains a set of tests to demonstrate how Events and Processes can be mixed. Chapter 10 covers an in depth explanation about this example. 


For updates about the book visit: http://salaboy.com / http://ilesteban.wordpress.com
or follow us on twitter: http://www.twitter.com/salaboy / http://www.twitter.com/ilesteban
- jBPM5 Developer Guide 2012

